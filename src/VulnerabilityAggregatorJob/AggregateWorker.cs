using InfluxDB.Client;
using InfluxDB.Client.Api.Domain;
using InfluxDB.Client.Writes;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System.IO.Compression;
using System.Net.Http.Headers;
using VulnerabilityAggregatorJob.Configuration;
using VulnerabilityAggregatorJob.Models;

namespace VulnerabilityAggregatorJob
{
    public class AggregateWorker : BackgroundService
    {
        private readonly ILogger<AggregateWorker> _logger;
        private readonly IHostApplicationLifetime _hostApplicationLifetime;
        private readonly IConfiguration _configuration;

        public AggregateWorker(IHostApplicationLifetime hostApplicationLifetime,  ILogger<AggregateWorker> logger, IConfiguration configuration)
        {
            _logger = logger;
            _hostApplicationLifetime = hostApplicationLifetime;
            _configuration = configuration;
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            while (!stoppingToken.IsCancellationRequested)
            {
                if (_logger.IsEnabled(LogLevel.Information))
                {
                    _logger.LogInformation("VulnerabilityAggregatorJob running at: {time}", DateTimeOffset.Now);
                }

                // Bind the "AzureDevOps" section to the AzureDevOpsConfig class
                var azureDevOpsConfig = new AzureDevOpsConfig();
                _configuration.GetSection("AzureDevOps").Bind(azureDevOpsConfig);

                var influxDbConfig = new InfluxDbConfig();
                _configuration.GetSection("InfluxDb").Bind(influxDbConfig);

                //var builds = await GetBuildsByPipelineName();
                var result = await GetLatestBuildNumbersAsync(azureDevOpsConfig);
                foreach (var build in result)
                {
                    _logger.LogInformation($"Pipeline: {build.Key}, Latest Build Number: {build.Value}");
                    string buildId = build.Value;
                    string pipelineName = build.Key;
                    var fileContent = await FetchBuildArtifact(azureDevOpsConfig, buildId);
                    if (fileContent != null)
                    {
                        var grypeScanVulnerabilities = ExtractAndReadGrypeScanResults(fileContent);
                        await PushToInfluxDbAsync(grypeScanVulnerabilities, influxDbConfig, pipelineName, build.Value);
                    }
                }


                await Task.Delay(1000, stoppingToken);
                // When completed, the entire app host will stop.

                if (_logger.IsEnabled(LogLevel.Information))
                {
                    _logger.LogInformation("VulnerabilityAggregatorJob finished at: {time}", DateTimeOffset.Now);
                }
                _hostApplicationLifetime.StopApplication();
            }
        }

        private async Task<Dictionary<string, string>> GetLatestBuildNumbersAsync(AzureDevOpsConfig azureDevOpsConfig)
        {
            var latestBuildNumbers = new Dictionary<string, string>();

            using (var client = new HttpClient())
            {
                client.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));
                client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Basic",
                    Convert.ToBase64String(System.Text.Encoding.ASCII.GetBytes($":{azureDevOpsConfig.Pat}")));

                var pipelinesUrl = $"https://dev.azure.com/{azureDevOpsConfig.Org}/{azureDevOpsConfig.Project}/_apis/build/definitions?api-version={azureDevOpsConfig.ApiVersion}";
                var pipelinesResponse = await client.GetAsync(pipelinesUrl);
                pipelinesResponse.EnsureSuccessStatusCode();
                var pipelinesContent = await pipelinesResponse.Content.ReadAsStringAsync();
                var pipelinesJson = JObject.Parse(pipelinesContent);

                foreach (var pipeline in pipelinesJson["value"])
                {
                    var pipelineName = pipeline["name"].ToString();
                    if (azureDevOpsConfig.PipelinePostfix != null && pipelineName.Contains(azureDevOpsConfig.PipelinePostfix))
                    {
                        var pipelineId = pipeline["id"].ToString();
                        var buildsUrl = $"https://dev.azure.com/{azureDevOpsConfig.Org}/{azureDevOpsConfig.Project}//_apis/build/builds?definitions={pipelineId}&$top=1&api-version={azureDevOpsConfig.ApiVersion}";
                        var buildsResponse = await client.GetAsync(buildsUrl);
                        buildsResponse.EnsureSuccessStatusCode();
                        var buildsContent = await buildsResponse.Content.ReadAsStringAsync();
                        var buildsJson = JObject.Parse(buildsContent);

                        if (buildsJson["value"].HasValues)
                        {
                            var latestBuildId = buildsJson["value"][0]["id"].ToString();
                            latestBuildNumbers.Add(pipelineName, latestBuildId);
                        }
                    }
                }
            }

            return latestBuildNumbers;
        }

        private async Task<byte[]> FetchBuildArtifact(AzureDevOpsConfig azureDevOpsConfig, string buildId)
        {
            using (var client = new HttpClient())
            {
                client.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));
                client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Basic",
                    Convert.ToBase64String(System.Text.ASCIIEncoding.ASCII.GetBytes($":{azureDevOpsConfig.Pat}")));

                // Get the list of artifacts for the build
                var artifactsUrl = $"https://dev.azure.com/{azureDevOpsConfig.Org}/{azureDevOpsConfig.Project}/_apis/build/builds/{buildId}/artifacts?api-version={azureDevOpsConfig.ApiVersion}";
                var artifactsResponse = await client.GetAsync(artifactsUrl);
                artifactsResponse.EnsureSuccessStatusCode();
                var artifactsContent = await artifactsResponse.Content.ReadAsStringAsync();
                var artifactsJson = JObject.Parse(artifactsContent);

                // Find the specific artifact
                string? downloadUrl = null;
                foreach (var artifact in artifactsJson["value"])
                {
                    if (artifact["name"].ToString() == azureDevOpsConfig.ArtifactName)
                    {
                        downloadUrl = artifact["resource"]["downloadUrl"].ToString();
                        break;
                    }
                }

                if (downloadUrl != null)
                {
                    // Download the specific file from the artifact
                    var fileResponse = await client.GetAsync(downloadUrl);
                    fileResponse.EnsureSuccessStatusCode();
                    return await fileResponse.Content.ReadAsByteArrayAsync();
                }
            }
            return null;
        }

        private MatchesRoot ExtractAndReadGrypeScanResults(byte[] zipContent)
        {
            using (var memoryStream = new MemoryStream(zipContent))
            {
                using (var archive = new ZipArchive(memoryStream))
                {
                    foreach (var entry in archive.Entries)
                    {
                        if (entry.FullName.EndsWith("grype-scan-results.json", StringComparison.OrdinalIgnoreCase))
                        {
                            using (var entryStream = entry.Open())
                            using (var streamReader = new StreamReader(entryStream))
                            {
                                string jsonContent = streamReader.ReadToEnd();
                                var result = JsonConvert.DeserializeObject<MatchesRoot>(jsonContent);
                                if (result == null)
                                {
                                    throw new InvalidOperationException("Deserialization resulted in a null object.");
                                }
                                return result;
                            }
                        }
                    }
                }
            }

            throw new FileNotFoundException("grype-scan-results.json not found in the zip archive.");
        }

        private async Task PushToInfluxDbAsync(MatchesRoot grypeScanVulnerabilities, InfluxDbConfig influxDbConfig, string pipelineName, string buildId)
        {
            using var influxDBClient = InfluxDBClientFactory.Create(influxDbConfig.Url, influxDbConfig.Token.ToCharArray());
            var writeApi = influxDBClient.GetWriteApiAsync();
            Guid guid = Guid.NewGuid(); // Generate a unique identifier for this scan

            foreach (var match in grypeScanVulnerabilities.Matches.Where(m => m.Vulnerability != null))
            {
                var vulnerability = match.Vulnerability;
                var artifact = match.Artifact;
                var cvss = vulnerability.Cvss?.FirstOrDefault();
                if (vulnerability != null)
                {
                    _logger.LogInformation("Writing vulnerability {vulnerability.Id} to InfluxDB");
                    var point = PointData.Measurement("vulnerabilities")
                        .Tag("pipeline", pipelineName)
                        .Tag("name", artifact.Name)
                        .Tag("id", guid.ToString("N"))
                        .Field("build_id", buildId)
                        .Field("severity", vulnerability.Severity)
                        .Field("namespace", vulnerability.Namespace)
                        .Field("type", artifact.Type)
                        .Field("version", artifact.Version)
                        .Field("description", vulnerability.Description)
                        .Field("data_source", vulnerability.DataSource)
                        .Field("cvss_score", cvss?.Metrics?.BaseScore ?? 0)
                        .Field("cvss_vector", cvss?.Vector ?? string.Empty)
                        .Field("fix_state", vulnerability.Fix?.State ?? string.Empty)
                        .Field("fix_versions", string.Join(",", vulnerability.Fix?.Versions ?? new List<string>()))
                        .Timestamp(DateTime.UtcNow, WritePrecision.Ns);

                    await writeApi.WritePointAsync(point, influxDbConfig.Bucket, influxDbConfig.Org);
                }
            }
        }
    }
}

